# -*- coding: utf-8 -*-
"""Getting_Starting_Yolo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1josPNPUR-GtpPz4D1ne1H99F9yjKCn4_
"""

import zipfile
import pandas as pd
import os
from sklearn.model_selection import train_test_split
import shutil
import datetime
import pathlib
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import random
from PIL import Image

from google.colab import drive
drive.mount('/content/drive')

from google.colab import drive
drive.mount('/content/drive')

"""## Carregando os dados de treino"""

train = pd.read_csv('/content/drive/MyDrive/Competição Zindi/Train.csv')
print(train.shape)
train.head(5)

# Excluindo as imagemns com nenhuma habitação
print(train.isnull().sum())
train = train.dropna()

train.shape

train['category_id'] = train['category_id'] - 1
train.category_id.unique()

"""## Preparação dos Dados

### Listando o Tamanho das Imagens
"""

# Listando as imagens com tamanho 1000x1000
def lista_nomes_imagens_1000x1000(caminho_pasta):
    nomes_imagens = []
    for nome_arquivo in os.listdir(caminho_pasta):
        caminho_arquivo = os.path.join(caminho_pasta, nome_arquivo)
        if os.path.isfile(caminho_arquivo):
            try:
                with Image.open(caminho_arquivo) as img:
                    largura, altura = img.size
                    if largura == 1000 and altura == 1000:
                        nomes_imagens.append(nome_arquivo)
            except Exception as e:
                print(f"Erro ao processar o arquivo {caminho_arquivo}: {e}")
    return nomes_imagens

# Substitua 'caminho_da_pasta' pelo caminho da pasta onde suas imagens estão localizadas
caminho_da_pasta = '/content/drive/MyDrive/Competição Zindi/Images'
nomes_imagens_1000x1000 = lista_nomes_imagens_1000x1000(caminho_da_pasta)
print(nomes_imagens_1000x1000)

# (Opcional) Salvar a lista das imagens 1000x1000 em json
import json
save_size1000 = {'imagens1000x1000':nomes_imagens_1000x1000}
destino ='/content/drive/MyDrive/Competição Zindi/listar_imagens_tamanho.json'
with open(destino,'w') as file:
  json.dump(save_size1000,file)

nomes_imagens_1000x1000 = [nome.split('.')[0] for nome in nomes_imagens_1000x1000]

"""### Ajustando os dados de treino e teste para o formato do YoLo"""

# Substituir vírgulas e colchetes por uma string vazia na coluna 'bbox'
train['bbox'] = train['bbox'].astype(str).str.replace(r'\[|\]|,', '', regex=True)

# Dividir os valores da coluna em colunas separadas
train[['x_center', 'y_center', 'tamanho', 'altura']] = train['bbox'].str.split(expand=True)
# Transformando em variáveis numéricas
train[['x_center', 'y_center', 'tamanho', 'altura']]= train[['x_center', 'y_center', 'tamanho', 'altura']].astype(float)

"""Para o treinamento, o modelo recebe como entrada a imagem, os bounding boxes, que indica as regiões onde estão os obejtos na imagem e as labels das classes que cada um dos objetos. Porém, as coordenadas da boxes devem ser normalizadas, e sendo passadas para o modelo as coordenadas do centro da box e sua altura e largura."""

# Função para normalizar as coordenadas das bounding boxes
def normalizacao(df):
    for index, row in df.iterrows():
        if row['image_id'] in nomes_imagens_1000x1000:
            df.at[index, 'x_center'] = (row['x_center'] + row['tamanho'] / 2) / 1000
            df.at[index, 'y_center'] = (row['y_center'] + row['altura'] / 2) / 1000
            df.at[index, 'tamanho'] = row['tamanho'] / 1000
            df.at[index, 'altura'] = row['altura'] / 1000
        else:
            df.at[index, 'x_center'] = (row['x_center'] + row['tamanho'] / 2) / 500
            df.at[index, 'y_center'] = (row['y_center'] + row['altura'] / 2) / 500
            df.at[index, 'tamanho'] = row['tamanho'] / 500
            df.at[index, 'altura'] = row['altura'] / 500
    return df

# Fazendo uma copia do dataframe original e aplicando a normalização
df_txt = train.copy()
normalizacao(df_txt)

# Criando um nova coluna bbox com as coordenadas normalizadas
df_txt['bbox'] = df_txt['x_center'].astype(str) + ' ' + df_txt['y_center'].astype(str) + ' ' + df_txt['tamanho'].astype(str) + ' ' + df_txt['altura'].astype(str)
df_txt.drop(['x_center', 'y_center', 'tamanho', 'altura'], axis=1 , inplace=True)

df_txt.to_csv('/content/drive/MyDrive/Competição Zindi/norma_yolo.csv')

"""### Divisão entre imagens de teste e imagens de treino"""

unique_images = df_txt['image_id'].unique()

val_size = int(len(unique_images) * 0.2)

train_imgs = unique_images[:(len(unique_images) - val_size)]
val_imgs = unique_images[-val_size:]

train_idx = np.isin(df_txt['image_id'].values, train_imgs)
val_idx = np.isin(df_txt['image_id'].values, val_imgs)

treino_df = df_txt.iloc[train_idx]
teste_df = df_txt.iloc[val_idx]

print(treino_df['image_id'].nunique())
print(teste_df['image_id'].nunique())

treino_df.to_csv('/content/drive/MyDrive/Competição Zindi/treino_norm.csv', index=False)
teste_df.to_csv('/content/drive/MyDrive/Competição Zindi/test_norm.csv', index=False)

"""### Dividindo as imagens de treino e teste em diretórios distintos

As imagens que serão utlizadas para treino e teste devem ser movidas para um diretório próprio. Uma pasta deve conter as imagens de treino e suas respectivas bbox com as classes que elas pertencem.
"""

diretorio_origem = "/content/drive/MyDrive/Competição Zindi/Images"
diretorio_destino_treino = "/content/drive/MyDrive/Competição Zindi/train/images"
diretorio_destino_teste = "/content/drive/MyDrive/Competição Zindi/test/images"

# Função para copiar as imagens para suas respectivas pastas
def copiar_imagens_para_pasta(dataframe, diretorio_origem, diretorio_destino):
    for _, row in dataframe.iterrows():
      try:
        imagem = row['image_id'] + '.tif'
        caminho_imagem_origem = os.path.join(diretorio_origem, imagem)
        caminho_imagem_destino = os.path.join(diretorio_destino, imagem)
        shutil.copy(caminho_imagem_origem, caminho_imagem_destino)
      except FileNotFoundError:
        print(f'Imagem não encontrada: {imagem}')

# Criar pastas de destino, se ainda não existirem
if not os.path.exists(diretorio_destino_treino):
    os.makedirs(diretorio_destino_treino)

if not os.path.exists(diretorio_destino_teste):
    os.makedirs(diretorio_destino_teste)

# Copiar as imagens de treino para a pasta de treino
copiar_imagens_para_pasta(treino_df, diretorio_origem, diretorio_destino_treino)

# Copiar as imagens de teste para a pasta de teste
copiar_imagens_para_pasta(teste_df, diretorio_origem, diretorio_destino_teste)

#CONTAR IMAGENS NO DIRETORIO DE TREINO
import os

def contar_imagens(diretorio):
    contador = 0
    for arquivo in os.listdir(diretorio):
        # Verificar se o arquivo é uma imagem (por exemplo, com extensão .jpg, .png, .jpeg, etc.)
        if arquivo.endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tif', '.tiff')):
            contador += 1
    return contador

# Diretório onde estão as imagens
dir = '/content/drive/MyDrive/Competição Zindi/train/images'

# Contar quantas imagens existem dentro do diretório
total_imagens = contar_imagens(dir)
print("Total de imagens no diretório:", total_imagens)

#CONTAR IMAGENS NO DIRETORIO DE TESTE
import os

def contar_imagens(diretorio):
    contador = 0
    for arquivo in os.listdir(diretorio):
        # Verificar se o arquivo é uma imagem (por exemplo, com extensão .jpg, .png, .jpeg, etc.)
        if arquivo.endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tif', '.tiff')):
            contador += 1
    return contador

# Diretório onde estão as imagens
dir_test = '/content/drive/MyDrive/Competição Zindi/test/images'

# Contar quantas imagens existem dentro do diretório
total_imagens = contar_imagens(dir_test)
print("Total de imagens no diretório:", total_imagens)

"""As bounding boxes das imagens e suas respctivas classes devem estar contidas em arquivo do tipo '_nome_da_imagem.txt_'. Arquivo deve ter a
seguinte estrutura, para cada objeto presente na imagem:

**classe x_center, y_center, largura, altura**
"""

#txt de treino
grouped_data = treino_df.groupby('image_id')

# Diretório de saída para os arquivos de texto
output_dir = "/content/drive/MyDrive/Competição Zindi/train/labels"
os.makedirs(output_dir, exist_ok=True)

# Iterar sobre cada grupo
for image_id, group in grouped_data:
    # Nome do arquivo de saída
    output_filename = os.path.join(output_dir, f"{image_id}.txt")

    # Abrir o arquivo de saída
    with open(output_filename, 'w') as file:
        # Iterar sobre cada linha do grupo
        for index, row in group.iterrows():
            # Escrever a classe e as coordenadas da caixa delimitadora no arquivo
            bbox = row['bbox']
            class_id = row['category_id']
            file.write(f"{class_id} {bbox}\n")

#CONTAR LABELS NO DIRETORIO DE TREINO
import os

def contar_imagens(diretorio):
    contador = 0
    for arquivo in os.listdir(diretorio):
        # Verificar se o arquivo é uma imagem (por exemplo, com extensão .jpg, .png, .jpeg, etc.)
        if arquivo.endswith(('.jpg', '.jpeg', '.png', '.txt', '.bmp', '.tif', '.tiff')):
            contador += 1
    return contador

# Diretório onde estão as imagens
diretorio = '/content/drive/MyDrive/Competição Zindi/train/labels'

# Contar quantas imagens existem dentro do diretório
total_imagens = contar_imagens(diretorio)
print("Total de imagens no diretório:", total_imagens)

#txt de teste
grouped_data = teste_df.groupby('image_id')

# Diretório de saída para os arquivos de texto
output_dir = "/content/drive/MyDrive/Competição Zindi/test/labels"
os.makedirs(output_dir, exist_ok=True)

# Iterar sobre cada grupo
for image_id, group in grouped_data:
    # Nome do arquivo de saída
    output_filename = os.path.join(output_dir, f"{image_id}.txt")

    # Abrir o arquivo de saída
    with open(output_filename, 'w') as file:
        # Iterar sobre cada linha do grupo
        for index, row in group.iterrows():
            # Escrever a classe e as coordenadas da caixa delimitadora no arquivo
            bbox = row['bbox']
            class_id = row['category_id']
            file.write(f"{class_id} {bbox}\n")

#CONTAR LABELS NO DIRETORIO DE TESTE
import os

def contar_imagens(diretorio):
    contador = 0
    for arquivo in os.listdir(diretorio):
        # Verificar se o arquivo é uma imagem (por exemplo, com extensão .jpg, .png, .jpeg, etc.)
        if arquivo.endswith(('.jpg', '.jpeg', '.png', '.txt', '.bmp', '.tif', '.tiff')):
            contador += 1
    return contador

# Diretório onde estão as imagens
diretorio = '/content/drive/MyDrive/Competição Zindi/test/labels'

# Contar quantas imagens existem dentro do diretório
total_imagens = contar_imagens(diretorio)
print("Total de imagens no diretório:", total_imagens)

"""### Importando e instalndo o YOLO

Instalando a biblioteca ultralytics
"""

!pip install ultralytics

from ultralytics import YOLO
import os
import yaml

"""### Treinamento"""

# Fazendo download do modelo yolo
model = YOLO('yolov8m.pt')

"""O modelo (pré-treinado) foi treinado por 20 épocas. Como entrada de dados é necessário passar um arquivo .yaml com a seguinte estrutura.

**path: /content/drive/MyDrive/CompetiçãoZindi # diretório do dataset**

**train: /content/drive/MyDrive/Competição Zindi/train  # imagens de treino (relativo ao 'path')**

**val: /content/drive/MyDrive/Competição Zindi/test  # Imagens de validação (relativo ao 'path')**

**#Classes**

names:

  0: Others

  1: Tin

  2: Thatch

"""

# Treinamento
model.train(data = '/content/drive/MyDrive/Competição Zindi/config_comp.yaml',
             epochs=20,
             patience=5,
             batch=16,
             imgsz=320,
             workers=8,
             pretrained=True,
             resume=False,
             single_cls=False,
             project='/content/drive/MyDrive/Competição Zindi/runs',
             box=7.5,
             cls=0.5,
             dfl=0.5,
             val=True,
             degrees=0.3,
             hsv_s=0.3,
             hsv_v=0.3,
             scale=0.5,
             fliplr=0.5)

# Obtendo as metricas de performance do modelo
model = YOLO('/content/drive/MyDrive/Competição Zindi/runs/train42/weights/best.pt')
result = model.val(project='/content/drive/MyDrive/Competição Zindi/runs',
                   imgsz=320,
                   batch=16,
                   conf=0.7,
                   iou=0.7,
                   save_json=False,
                   save_hybrid=False,
                   split='val')

"""### Gerando previsões e fazendo submissões"""

# Função para contar as classes presentes em uma imagem
import json
# Importando o modelo
model = YOLO('/content/drive/MyDrive/Competição Zindi/runs/train42/weights/best.pt')
def get_classes_count(pred_json: str):
    classes_count = {}
    classes_count[0] = 0
    classes_count[1] = 0
    classes_count[2] = 0
    for j in json.loads(pred_json):
        classes_count[j['class']] += 1

    return classes_count

# Importando o conjunto de teste
test = pd.read_csv('/content/drive/MyDrive/Competição Zindi/Test.csv')

# Gerando arquivo para submissão
import os
import pandas as pd
from tqdm import tqdm

submission_df = pd.DataFrame(columns=["image_id", "Target"])

imagens_com_erro = []

for index, row in tqdm(test.iterrows(), total=len(test)):
    image_id = row['image_id']
    try:
        pred = model.predict(f"/content/drive/MyDrive/Competição Zindi/Images/{image_id}.tif",conf=0.7)
        pred_json = get_classes_count(pred[0].tojson())

        df = pd.DataFrame({"image_id" : [f"{image_id}_1", f"{image_id}_2", f"{image_id}_3"],
                          "Target" : [pred_json[0], pred_json[1], pred_json[2]]})

        submission_df = pd.concat([submission_df, df], axis=0)
    except Exception as e:

        print(f"Erro ao processar a imagem {image_id}: {e}")
        imagens_com_erro.append(image_id)


submission_df.to_csv("submission_7.csv", index=False)


if imagens_com_erro:
    print("As seguintes imagens causaram erro ao processar:", imagens_com_erro)
else:
    print("Todas as imagens foram processadas com sucesso.")